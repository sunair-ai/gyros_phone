<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Digital Twin - Enhanced</title>
    <style>
        body { margin: 0; font-family: monospace; background-color: #000; overflow: hidden; }
        canvas { display: block; }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            z-index: 100;
            color: white;
            background-color: rgba(0,0,0,0.5);
            padding: 5px;
            font-size: 14px;
        }
        #model-rotation {
            position: absolute;
            top: 40px;
            width: 100%;
            text-align: center;
            z-index: 100;
            color: white;
        }
        #controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0,0,0,0.7);
            padding: 20px;
            border-radius: 15px;
            color: white;
            display: flex;
            flex-direction: column;
            gap: 15px;
            width: 90%;
            max-width: 400px;
            box-sizing: border-box;
        }
        .slider-container {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
        }
        .slider-container label {
            flex-shrink: 0;
            font-weight: bold;
        }
        .slider-container input[type="range"] {
            flex-grow: 1;
            width: 100%;
        }
        .slider-container input[type="number"] {
            width: 70px;
            background-color: #222;
            color: white;
            border: 1px solid #666;
            border-radius: 5px;
            text-align: center;
            -moz-appearance: textfield; /* Firefox */
        }
        .slider-container input[type="number"]::-webkit-outer-spin-button,
        .slider-container input[type="number"]::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        /* --- MODIFIED: Low-opacity design for Calibration UI --- */
        #calibration-ui {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 25px;
            font-size: 22px;
            background-color: rgba(20, 20, 20, 0.85); /* Low opacity background */
            backdrop-filter: blur(10px); /* Frosted glass effect */
            -webkit-backdrop-filter: blur(10px);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 15px;
            text-align: center;
            width: 90%;
            max-width: 350px;
            box-sizing: border-box;
        }
        #calibration-ui button {
            margin-top: 25px;
            padding: 12px 25px;
            font-size: 18px;
            background-color: #008CBA;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        #calibration-ui button:hover {
            background-color: #005f7a;
        }
        #calibration-canvas-container {
            width: 200px;
            height: 200px;
            margin: 20px auto 0;
            background-color: rgba(0,0,0,0.3);
            border-radius: 10px;
            padding: 10px;
        }
    </style>
</head>
<body>
    <div id="info">Connecting to WebSocket...</div>
    <div id="model-rotation"></div>

    <!-- Calibration UI with low-opacity design -->
    <div id="calibration-ui">
        <p id="calibration-step-text">Step 1: Lay phone flat on a table.</p>
        <div id="calibration-canvas-container"></div>
        <button id="calibrate-step-button">Calibrate</button>
    </div>

    <div id="controls" style="display: none;">
        <div class="slider-container">
            <label for="offsetXSlider">X-Offset:</label>
            <input type="range" id="offsetXSlider" min="-180" max="180" value="0">
            <input type="number" id="offsetXInput" min="-180" max="180" value="0">
        </div>
        <div class="slider-container">
            <label for="offsetYSlider">Y-Offset:</label>
            <input type="range" id="offsetYSlider" min="-180" max="180" value="0">
            <input type="number" id="offsetYInput" min="-180" max="180" value="0">
        </div>
        <div class="slider-container">
            <label for="offsetZSlider">Z-Offset:</label>
            <input type="range" id="offsetZSlider" min="-180" max="180" value="0">
            <input type="number" id="offsetZInput" min="-180" max="180" value="0">
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        let phoneModel, offsetGroup, latestData = null;
        const infoDiv = document.getElementById('info');
        const modelRotationDiv = document.getElementById('model-rotation');
        const calibrationUi = document.getElementById('calibration-ui');
        const calibrationStepText = document.getElementById('calibration-step-text');
        const calibrateStepButton = document.getElementById('calibrate-step-button');
        const calibrationCanvasContainer = document.getElementById('calibration-canvas-container');
        const controlsDiv = document.getElementById('controls');

        // --- CALIBRATION VARIABLES ---
        let calibrationStep = 1;
        let calibrationData = { step1: null, step2: null, step3: null };
        let calibrated = false;
        let calibrationMatrix = new THREE.Matrix4();
        let calibScene, calibCamera, calibRenderer, calibModel;

        // --- OFFSET CONTROLS ---
        const setupControls = (slider, input, callback) => {
            slider.addEventListener('input', e => {
                const value = parseFloat(e.target.value);
                input.value = value;
                callback(value);
            });
            input.addEventListener('input', e => {
                const value = parseFloat(e.target.value);
                slider.value = value;
                callback(value);
            });
        };
        // We will apply offsets to the 'offsetGroup' which is the parent of the live-data model group.
        let offsetX = 0, offsetY = 0, offsetZ = 0;
        setupControls(document.getElementById('offsetXSlider'), document.getElementById('offsetXInput'), val => offsetX = val);
        setupControls(document.getElementById('offsetYSlider'), document.getElementById('offsetYInput'), val => offsetY = val);
        setupControls(document.getElementById('offsetZSlider'), document.getElementById('offsetZInput'), val => offsetZ = val);

        // --- WEBSOCKET ---
        const socket = new WebSocket('wss://' + window.location.hostname + ':8081');
        socket.onopen = () => { infoDiv.innerHTML = "✅ Connection successful. Please begin calibration."; };
        socket.onmessage = event => { latestData = JSON.parse(event.data); };
        socket.onerror = () => { infoDiv.innerHTML = "❌ WebSocket connection error."; };
        socket.onclose = () => { infoDiv.innerHTML = "🔌 WebSocket connection closed."; };

        // --- MAIN 3D SCENE ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x101010);
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0.1, 0.4);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        document.body.appendChild(renderer.domElement);
        renderer.setSize(window.innerWidth, window.innerHeight);
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;

        // --- LIGHTING ---
        scene.add(new THREE.AmbientLight(0xffffff, 0.8));
        const dirLight = new THREE.DirectionalLight(0xffffff, 1.5);
        dirLight.position.set(5, 10, 7.5);
        scene.add(dirLight);

        // --- MODEL LOADING ---
        const loader = new GLTFLoader();
        loader.load('models/samsung_phone.glb', gltf => {
            const loadedModel = gltf.scene;
            const box = new THREE.Box3().setFromObject(loadedModel);
            const center = box.getCenter(new THREE.Vector3());
            loadedModel.position.sub(center); // Center the model geometry

            // Group for live data rotation
            phoneModel = new THREE.Group();
            phoneModel.add(loadedModel);

            // Parent group for manual offset rotation
            offsetGroup = new THREE.Group();
            offsetGroup.add(phoneModel);

            scene.add(offsetGroup);
            phoneModel.visible = false; // Hide until calibrated

            // --- SETUP CALIBRATION PREVIEW SCENE ---
            calibScene = new THREE.Scene();
            calibScene.background = null; // Transparent background
            calibCamera = new THREE.PerspectiveCamera(75, 1, 0.1, 1000);
            calibCamera.position.z = 0.35;
            calibRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            calibRenderer.setPixelRatio(window.devicePixelRatio);
            calibRenderer.setSize(200, 200);
            calibrationCanvasContainer.appendChild(calibRenderer.domElement);
            calibScene.add(new THREE.AmbientLight(0xffffff, 1.2));
            const calibDirLight = new THREE.DirectionalLight(0xffffff, 1);
            calibDirLight.position.set(5, 10, 7.5);
            calibScene.add(calibDirLight);
            calibModel = loadedModel.clone();
            calibScene.add(calibModel);
            updateCalibrationVisuals();
        }, undefined, error => {
            console.error('An error happened during model loading:', error);
            infoDiv.innerHTML = "Error loading 3D model.";
        });

        // --- CALIBRATION LOGIC ---
        function updateCalibrationVisuals() {
            if (!calibModel) return;
            if (calibrationStep === 1) {
                calibrationStepText.innerHTML = "<b>Step 1:</b> Lay phone flat, screen up.";
                calibModel.rotation.set(0, 0, 0);
            } else if (calibrationStep === 2) {
                calibrationStepText.innerHTML = "<b>Step 2:</b> Hold phone upright (portrait).";
                calibModel.rotation.set(Math.PI / 2, 0, 0);
            } else if (calibrationStep === 3) {
                calibrationStepText.innerHTML = "<b>Step 3:</b> Hold phone sideways (landscape).";
                calibModel.rotation.set(Math.PI / 2, 0, -Math.PI / 2);
            }
        }

        calibrateStepButton.addEventListener('click', () => {
            if (!latestData) {
                // Use a custom modal/alert in a real app, as alert() can be blocked.
                alert("Waiting for data from phone. Please ensure your phone is connected and sending data.");
                return;
            }

            const { rot_x, rot_y, rot_z } = latestData;
            // Use 'YXZ' order, as it's common for device orientation and avoids gimbal lock in many cases.
            const euler = new THREE.Euler(
                THREE.MathUtils.degToRad(rot_x || 0),
                THREE.MathUtils.degToRad(rot_y || 0),
                THREE.MathUtils.degToRad(rot_z || 0),
                'YXZ'
            );
            const matrix = new THREE.Matrix4().makeRotationFromEuler(euler);

            if (calibrationStep === 1) {
                calibrationData.step1 = matrix;
                calibrationStep++;
                updateCalibrationVisuals();
            } else if (calibrationStep === 2) {
                calibrationData.step2 = matrix;
                calibrationStep++;
                updateCalibrationVisuals();
            } else if (calibrationStep === 3) {
                calibrationData.step3 = matrix;
                // Use the inverse of the first calibration step (flat position) to zero out the rotation.
                calibrationMatrix.copy(calibrationData.step1).invert();
                calibrated = true;
                phoneModel.visible = true;
                calibrationUi.style.display = 'none';
                controlsDiv.style.display = 'flex';
                infoDiv.innerHTML = "✅ Calibration Complete! You can now use the sliders.";
            }
        });

        // --- ANIMATION LOOP ---
        function animate() {
            requestAnimationFrame(animate);

            // Render the small calibration preview
            if (calibRenderer) {
                calibRenderer.render(calibScene, calibCamera);
            }

            if (phoneModel && offsetGroup && calibrated) {
                // 1. Apply manual offset rotations to the OUTER group
                offsetGroup.rotation.set(
                    THREE.MathUtils.degToRad(offsetX),
                    THREE.MathUtils.degToRad(offsetY),
                    THREE.MathUtils.degToRad(offsetZ),
                    'YXZ' // Use same order for consistency
                );

                // 2. Apply live data to the INNER group
                if (latestData) {
                    const { rot_x, rot_y, rot_z } = latestData;
                    
                    const currentEuler = new THREE.Euler(
                        THREE.MathUtils.degToRad(rot_x || 0),
                        THREE.MathUtils.degToRad(rot_y || 0),
                        THREE.MathUtils.degToRad(rot_z || 0),
                        'YXZ'
                    );
                    const currentMatrix = new THREE.Matrix4().makeRotationFromEuler(currentEuler);

                    // Apply calibration to the live data matrix
                    const finalMatrix = new THREE.Matrix4().multiplyMatrices(calibrationMatrix, currentMatrix);
                    const targetQuaternion = new THREE.Quaternion().setFromRotationMatrix(finalMatrix);

                    // --- STABILITY IMPLEMENTATION ---
                    // Slerp (Spherical Linear Interpolation) provides smooth, stable transitions.
                    phoneModel.quaternion.slerp(targetQuaternion, 0.08);
                }
            }

            controls.update();
            renderer.render(scene, camera);
        }

        // --- RESIZE HANDLER ---
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>
