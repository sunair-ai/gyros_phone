'''

Connecting to WebSocket...
Step 1: Lay phone flat on a table.

<!-- Updated HTML for the controls with number inputs -->
<div id="controls" style="display: none;">
    <div class="slider-container">
        <label for="offsetX">X-Offset:</label>
        <input type="range" id="offsetXSlider" min="-180" max="180" value="0">
        <input type="number" id="offsetXInput" min="-180" max="180" value="0">
    </div>
    <div class="slider-container">
        <label for="offsetY">Y-Offset:</label>
        <input type="range" id="offsetYSlider" min="-180" max="180" value="0">
        <input type="number" id="offsetYInput" min="-180" max="180" value="0">
    </div>
    <div class="slider-container">
        <label for="offsetZ">Z-Offset:</label>
        <input type="range" id="offsetZSlider" min="-180" max="180" value="0">
        <input type="number" id="offsetZInput" min="-180" max="180" value="0">
    </div>
</div>

<script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
</script>

<script type="module">
    // Import necessary components from Three.js
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

    // --- GLOBAL VARIABLES ---
    let phoneModel; // This will be the INNER pivot for live data
    let offsetGroup; // This will be the OUTER pivot for manual offsets
    let latestData = null;
    const infoDiv = document.getElementById('info');
    const modelRotationDiv = document.getElementById('model-rotation');
    const calibrationUi = document.getElementById('calibration-ui');
    const calibrationStepText = document.getElementById('calibration-step-text');
    const calibrateStepButton = document.getElementById('calibrate-step-button');
    const calibrationCanvas = document.getElementById('calibration-canvas');
    const controlsDiv = document.getElementById('controls');
    let calibrationStep = 1;
    let calibrationData = {
        step1: null,
        step2: null,
        step3: null,
    };
    let calibrated = false;
    let calibrationMatrix = new THREE.Matrix4();
    let calibScene, calibCamera, calibRenderer, calibModel;

    // --- SLIDER & INPUT CONTROL VARIABLES ---
    let offsetX = 0, offsetY = 0, offsetZ = 0;
    const offsetXSlider = document.getElementById('offsetXSlider');
    const offsetYSlider = document.getElementById('offsetYSlider');
    const offsetZSlider = document.getElementById('offsetZSlider');
    const offsetXInput = document.getElementById('offsetXInput');
    const offsetYInput = document.getElementById('offsetYInput');
    const offsetZInput = document.getElementById('offsetZInput');

    // --- TWO-WAY BINDING FOR CONTROLS ---
    function setupControls(slider, input, callback) {
        slider.addEventListener('input', (e) => {
            const value = parseFloat(e.target.value);
            input.value = value;
            callback(value);
        });
        input.addEventListener('input', (e) => {
            const value = parseFloat(e.target.value);
            slider.value = value;
            callback(value);
        });
    }
    setupControls(offsetXSlider, offsetXInput, (val) => offsetX = val);
    setupControls(offsetYSlider, offsetYInput, (val) => offsetY = val);
    setupControls(offsetZSlider, offsetZInput, (val) => offsetZ = val);

    // --- WEBSOCKET SETUP ---
    const socket = new WebSocket('wss://' + window.location.hostname + ':8081');
    socket.onopen = () => { infoDiv.innerHTML = "Connection open. Waiting for data from phone..."; };
    socket.onmessage = (event) => { latestData = JSON.parse(event.data); };
    socket.onerror = () => { infoDiv.innerHTML = "WebSocket connection error."; };
    socket.onclose = () => { infoDiv.innerHTML = "WebSocket connection closed."; };

    // --- SCENE SETUP ---
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x222222);
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 0.3;
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);
    // const controls = new OrbitControls(camera, renderer.domElement);
    // controls.enableDamping = true;

    // --- LIGHTING ---
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
    scene.add(ambientLight);
    const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
    directionalLight.position.set(5, 10, 7.5);
    scene.add(directionalLight);

    // --- MODEL LOADER ---
    const loader = new GLTFLoader();
    loader.load('models/samsung_phone.glb', (gltf) => {
        const loadedModel = gltf.scene;
        const box = new THREE.Box3().setFromObject(loadedModel);
        const center = box.getCenter(new THREE.Vector3());
        loadedModel.position.sub(center);

        // This group handles the live gyro data
        phoneModel = new THREE.Group();
        phoneModel.add(loadedModel);

        // This new parent group handles the manual offset
        offsetGroup = new THREE.Group();
        offsetGroup.add(phoneModel);

        // Add the outer group to the scene
        scene.add(offsetGroup);
        phoneModel.visible = false;
        console.log('Model loaded and centered successfully!');

        // --- CALIBRATION SCENE ---
        calibScene = new THREE.Scene();
        calibScene.background = new THREE.Color(0x444444);
        calibCamera = new THREE.PerspectiveCamera(75, 1, 0.1, 1000);
        calibCamera.position.z = 0.3;
        calibRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        calibRenderer.setSize(200, 200);
        calibrationCanvas.appendChild(calibRenderer.domElement);
        const calibLight = new THREE.AmbientLight(0xffffff, 1);
        calibScene.add(calibLight);
        const calibDirLight = new THREE.DirectionalLight(0xffffff, 1);
        calibDirLight.position.set(5, 10, 7.5);
        calibScene.add(calibDirLight);

        calibModel = loadedModel.clone();
        calibScene.add(calibModel);
        updateCalibrationVisuals();
    });

    // --- CALIBRATION ---
    function updateCalibrationVisuals() {
        if (calibrationStep === 1) {
            calibrationStepText.textContent = 'Step 1: Lay phone flat on a table.';
            calibModel.rotation.set(0, 0, 0);
        } else if (calibrationStep === 2) {
            calibrationStepText.textContent = 'Step 2: Hold phone upright in portrait mode.';
            calibModel.rotation.set(Math.PI / 2, 0, 0);
        } else if (calibrationStep === 3) {
            calibrationStepText.textContent = 'Step 3: Hold phone in landscape mode.';
            calibModel.rotation.set(0, 0, Math.PI / 2);
        }
    }

    calibrateStepButton.addEventListener('click', () => {
        if (latestData) {
            const alpha = latestData.rot_z ? THREE.MathUtils.degToRad(latestData.rot_z) : 0; // Z
            const beta = latestData.rot_x ? THREE.MathUtils.degToRad(latestData.rot_x) : 0; // X
            const gamma = latestData.rot_y ? THREE.MathUtils.degToRad(latestData.rot_y) : 0; // Y
            const euler = new THREE.Euler(beta, alpha, -gamma, 'YXZ');
            const matrix = new THREE.Matrix4().makeRotationFromEuler(euler);

            if (calibrationStep === 1) {
                calibrationData.step1 = matrix;
                calibrationStep++;
                updateCalibrationVisuals();
            } else if (calibrationStep === 2) {
                calibrationData.step2 = matrix;
                calibrationStep++;
                updateCalibrationVisuals();
            } else if (calibrationStep === 3) {
                calibrationData.step3 = matrix;

                //
                // We can now calculate the calibration matrix.
                //
                // This is a simplified approach. For a more robust solution,
                // you would use a more advanced algorithm like Singular Value Decomposition (SVD)
                // to find the optimal rotation matrix that best aligns the three calibration poses.
                //
                // For now, we'll just use the inverse of the first calibration step.
                //
                calibrationMatrix.copy(calibrationData.step1).invert();

                calibrated = true;
                phoneModel.visible = true;
                calibrationUi.style.display = 'none';
                controlsDiv.style.display = 'flex';
            }
        }
    });


    // --- ANIMATION LOOP ---
    function animate() {
        requestAnimationFrame(animate);

        if(calibRenderer) {
            calibRenderer.render(calibScene, calibCamera);
        }

        // Check if our groups have been created
        if (phoneModel && offsetGroup && calibrated) {
            // 1. Apply live data rotation to the INNER group
            if (latestData) {
                infoDiv.innerHTML = `Phone Rotation: X=${latestData.rot_x}, Y=${latestData.rot_y}, Z=${latestData.rot_z}`;
                let modelEuler = new THREE.Euler().setFromQuaternion(phoneModel.quaternion, 'YXZ');
                modelRotationDiv.innerHTML = `Model Rotation: X=${(modelEuler.x * 180 / Math.PI).toFixed(2)}, Y=${(modelEuler.y * 180 / Math.PI).toFixed(2)}, Z=${(modelEuler.z * 180 / Math.PI).toFixed(2)}`;

                const alpha = latestData.rot_z ? THREE.MathUtils.degToRad(latestData.rot_z) : 0; // Z
                const beta = latestData.rot_x ? THREE.MathUtils.degToRad(latestData.rot_x) : 0; // X
                const gamma = latestData.rot_y ? THREE.MathUtils.degToRad(latestData.rot_y) : 0; // Y
                const currentEuler = new THREE.Euler(beta, alpha, -gamma, 'YXZ');
                const currentMatrix = new THREE.Matrix4().makeRotationFromEuler(currentEuler);

                const finalMatrix = new THREE.Matrix4().multiplyMatrices(currentMatrix, calibrationMatrix);
                const quaternion = new THREE.Quaternion().setFromRotationMatrix(finalMatrix);

                phoneModel.quaternion.slerp(quaternion, 0.1);
            }

            // 2. Apply manual offset rotation to the OUTER group
            offsetGroup.rotation.order = 'YXZ';
            offsetGroup.rotation.y = offsetY * (Math.PI / 180);
            offsetGroup.rotation.x = offsetX * (Math.PI / 180);
            offsetGroup.rotation.z = offsetZ * (Math.PI / 180);
        }

        // controls.update();
        renderer.render(scene, camera);
    }

    // --- RESIZE HANDLER ---
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    animate();
</script>
'''
